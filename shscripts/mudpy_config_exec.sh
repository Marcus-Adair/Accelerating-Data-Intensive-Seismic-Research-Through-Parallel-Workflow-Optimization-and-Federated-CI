#  Written by Marcus Adair under Ivan Rodero, University of Utah, June 2022
#
#  Executable file for running a single fakequakes simulation.
#
#   DO NOT EDIT THIS FILE. IT IS MEANT TO BE CALLED BY WRAPPER FILES (unless you know what you're doing)
#  
#  This is meant to be held in a Singularity container which was built for running fakequake simulations.
#
#  This runs a simulation and either calculates the distance and G matrices if the runnumber is 0,
#  else it recyles matrices that are in the home dir held in a tarball called matricesoutput.tar.gz       
#
#  It is assumed that some sort of 'project name' is passed in as the $1 argrument to this script.
#  It can be any word but must contain a number which is 0 or some positive number. This script extracts that 
#  number in the 'project name' and uses it as a runnumber. (So unless you are recycling distance or G matrices,
#  always have it so the runnumber will be 0. (e.g pass in as an argument to this script: "fakequakes_run0")  )
#
#  This script assumes there's a tarball in the home dir which holds the 5 neccesary input files for fakequakes to run.
#  These are files that end in .mod, .xyz, .mshout, gflist, .fault (one of each) and are held in 'preparedinput.tar.gz'
#  To prepare your own files for fakequake simulations: 
#  1. Create a directory called 'preparedinput'. 2. Move files (.mod, .xyz, etc.) into the new dir.
#  3. Wrap to a tarbal with command 'tar -czf preparedinput.tar.gz preparedinput'   4. Move 'preparedinput.tar.gz' to the home directory before running this script (~).
#
#  To run a fakequakes simulation, after creating a tarball with your prepared input files, edit a configuration file which calls this script.
#  (This configuration file is inside of the Singularity image or also exists on the OSG)
#  MAKE SURE THAT YOUR INPUT FILES' NAMES MATCH THEIR CORRESPONDING PARAMETERS BELOW (model_name, fault_name, slab_name, mesh_name, gf_list)


#### ----- Configure Parameters below ---------

#  Get the job name from submit file arguments. This is be the name of the directory initialized by
#  MudPy, and each job's output will be transferred out via the stash in the format $PROJNAME.tar.gz
PROJNAME=$1
HOMEPATH=$2

ncpus=$3                             # Number of CPUs. Set to 1 when first running make_ruptures=1     
run_name=$4                    # Run name (Note: this is not linked to the 'runnumber' mentioned above)

model_name=$5          # Velocity model
fault_name=$6              # Fault geometry
slab_name=$7                 # Slab 1.0 Ascii file (only used for 3D fault)
mesh_name=$8              # GMSH output file (only used for 3D fault)
distances_name=$9    # Name of distance matrix
utm_zone=${10}                        # Look here if unsure (https://en.wikipedia.org/wiki/Universal_Transverse_Mercator_coordinate_system#/media/File:Utm-zones.jpg)
scaling_law=${11}                       # Options: T for thrust, S for strike-slip, N for normal
dynamic_gflist=${12}                    # dynamic GFlist (True/False)
dist_threshold=${13}                 # #(degree) station to the closest subfault must be closer to this distance

#slip parameters
nrealizations=${14}                     # Number of fake ruptures to generate per magnitude bin. let Nrealizations % ncpus=0
target_mw=${15}               # Of what approximate magnitudes, parameters of numpy.arange()
max_slip=${16}                        # Maximum slip (m) allowed in the model

# Correlation function parameters
hurst=${17}                           # 0.4~0.7 is reasonable
ldip=${18}                           # Correlation length scaling, 'auto' uses  Mai & Beroza 2002, 
lstrike=${19}                        # MH2019 uses Melgar & Hayes 2019
lognormal=${20}			                # (True/False)
slip_standard_deviation=${21}
num_modes=${22}                       # Modes in K-L expantion (max#= munber of subfaults )
rake=${23}

# Rupture parameters
force_magnitude=${24}                   # Make the magnitudes EXACTLY the value in target_Mw (True/False)
force_area=${25}                        # Forces using the entire fault area defined by the .fault file as opposed to the scaling law (True/False)s
no_random=${26}                         # If true uses median length/width if false draws from prob. distribution (True/False)
time_epi=${27}        # Defines the hypocentral time
hypocenter=${28}        # Defines the specific hypocenter location if force_hypocenter=True
force_hypocenter=${29}                  # Forces hypocenter to occur at specified lcoationa s opposed to random (True/False)
mean_slip=${30}                      # Provide path to file name of .rupt to be used as mean slip pattern
center_subfault=${31}                # Integer value, if != None use that subfault as center for defining rupt area. If none then slected at random
use_hypo_fraction=${32}                 # If true use hypocenter PDF positions from Melgar & Hayes 2019, if false then selects at random   (True/False)

# Kinematic parameters
source_time_function=${33}         # options are 'triangle' or 'cosine' or 'dreger'
rise_time_depths=${34}             # Transition depths for rise time scaling
shear_wave_fraction=${35}             # Fraction of shear wave speed to use as mean rupture velocity
shear_wave_fraction_deep=${36}
shear_wave_fraction_shallow=${37}

# Station information (only used when syntehsizing waveforms)
gf_list=${38}
g_name=${39}

# Displacement and velocity waveform parameters and fk-parameters
nfft=${40}
dt=${41}
zeta=${42}
dk=${43}
pmin=${44}
pmax=${45}
kmax=${46}
custom_stf=${47}
rupture_list=${48}         # Don't change this (unless you know waht you're doing!)
max_slip_rule=${49}
slip_tol=${50}
stf_falloff_rate=${51}
rupture_name=${52}
hot_start=${53}
impulse=${54}				# (True/False)
epicenter=${55}

########---------------- DO NOT CHANGE ANYTHING UNDER THIS (unless you know what you're doing)

##############################################################################################

#     This goes through and executes all steps of fakequakes simulations including moving the prepared input to the right places.
#     When this is done there will be a directory in the home dir named after 'project name' which was passed in as an argument.

# Have job exit if any command returns with non-zero exit status (aka failure)
set -e

# get the runnumber off the project_name (each project name should have a number in it which is N and the runnumber)
runnum=$(echo "$PROJNAME" | tr -dc '0-9') 

# If there is no number on the project name, thus no runnumber given, set it to 0 
if [ -z $runnum ]; then
    runnum=0
fi

# for testing*
export PYTHONPATH=/MudPy/src/python:$PYTHONPATH         ##*** TODO: remove this line before building the new image, (cuz i messed up PYTHONPATH in 1st image)

# activate the python environment built in to this Singularity image
cd /
. quake3.6/bin/activate
cd ~

# Have MudPy intialize a folder structure to write output data to named $PROJNAME. Pass in the path of the working dir and the name of the unique project_name
python3 /MudPy/examples/fakequakes/planar/mudpy_single_exec_chile.fq.py init -load_distances=0 -g_from_file=0 -ncpus=$ncpus -model_name=$model_name -fault_name=$fault_name -epicenter=$epicenter -slab_name=$slab_name -mesh_name=$mesh_name -distances_name=$distances_name -utm_zone=$utm_zone -scaling_law=$scaling_law -dynamic_gflist=$dynamic_gflist -dist_threshold=$dist_threshold -nrealizations=$nrealizations -max_slip=$max_slip -hurst=$hurst -ldip=$ldip -lstrike=$lstrike -lognormal=$lognormal -slip_standard_deviation=$slip_standard_deviation -num_modes=$num_modes -rake=$rake -force_magnitude=$force_magnitude -force_area=$force_area -no_random=$no_random -time_epi=$time_epi -hypocenter=$hypocenter -force_hypocenter=$force_hypocenter -mean_slip=$mean_slip -center_subfault=$center_subfault -use_hypo_fraction=$use_hypo_fraction -source_time_function=$source_time_function -rise_time_depths=$rise_time_depths -shear_wave_fraction=$shear_wave_fraction -gf_list=$gf_list -g_name=$g_name -nfft=$nfft -dt=$dt -dk=$dk -pmin=$pmin -pmax=$pmax -kmax=$kmax -custom_stf=$custom_stf -rupture_list=$rupture_list -target_mw=$target_mw -max_slip_rule=$max_slip_rule -slip_tol=$slip_tol -shear_wave_fraction_deep=$shear_wave_fraction_deep -shear_wave_fraction_shallow=$shear_wave_fraction_shallow -zeta=$zeta -stf_falloff_rate=$stf_falloff_rate -rupture_name=$rupture_name -hot_start=$hot_start -impulse=$impulse -home=$HOMEPATH -project_name=$PROJNAME -run_name=$run_name

# Unpack the input files prepared by the user
# and move into the directory containing them     
tar -xzf  preparedinput.tar.gz
cd preparedinput
mv *.mod $HOMEPATH/$PROJNAME/structure
mv *.fault $HOMEPATH/$PROJNAME/data/model_info
mv *.mshout $HOMEPATH/$PROJNAME/data/model_info
mv *.xyz $HOMEPATH/$PROJNAME/data/model_info
mv *.gflist $HOMEPATH/$PROJNAME/data/station_info
cd ..               # go back

# if its not the initial simulation (if runnum != 0) recycle matrices
if [[ $runnum -ne 0 ]]; then
    # Unpack matrices and move to right place
    tar -xzf matricesoutput.tar.gz
    cd matricesoutput
    mv *.npy $HOMEPATH/$PROJNAME/data/distances
    mv *.mseed $HOMEPATH/$PROJNAME/GFs/matrices
    cd ..           
fi


# Run the first part of the fakequakes simulation. Pass in variables so that MudPy knows where to access data and write output to
# (make_ruptures)
if [[ $runnum -eq 0 ]]; then
    # calc distance matices
    python3 /MudPy/examples/fakequakes/planar/mudpy_single_exec_chile.fq.py make_ruptures -load_distances=0 -g_from_file=0 -ncpus=1 -model_name=$model_name -fault_name=$fault_name -epicenter=$epicenter -slab_name=$slab_name -mesh_name=$mesh_name -distances_name=$distances_name -utm_zone=$utm_zone -scaling_law=$scaling_law -dynamic_gflist=$dynamic_gflist -dist_threshold=$dist_threshold -nrealizations=$nrealizations -max_slip=$max_slip -hurst=$hurst -ldip=$ldip -lstrike=$lstrike -lognormal=$lognormal -slip_standard_deviation=$slip_standard_deviation -num_modes=$num_modes -rake=$rake -force_magnitude=$force_magnitude -force_area=$force_area -no_random=$no_random -time_epi=$time_epi -hypocenter=$hypocenter -force_hypocenter=$force_hypocenter -mean_slip=$mean_slip -center_subfault=$center_subfault -use_hypo_fraction=$use_hypo_fraction -source_time_function=$source_time_function -rise_time_depths=$rise_time_depths -shear_wave_fraction=$shear_wave_fraction -gf_list=$gf_list -g_name=$g_name -nfft=$nfft -dt=$dt -dk=$dk -pmin=$pmin -pmax=$pmax -kmax=$kmax -custom_stf=$custom_stf -rupture_list=$rupture_list -target_mw=$target_mw -max_slip_rule=$max_slip_rule -slip_tol=$slip_tol -shear_wave_fraction_deep=$shear_wave_fraction_deep -shear_wave_fraction_shallow=$shear_wave_fraction_shallow -zeta=$zeta -stf_falloff_rate=$stf_falloff_rate -rupture_name=$rupture_name -hot_start=$hot_start -impulse=$impulse -home=$HOMEPATH -project_name=$PROJNAME -run_name=$run_name
else
    # recycle distance matrices
    python3 /MudPy/examples/fakequakes/planar/mudpy_single_exec_chile.fq.py make_ruptures -load_distances=1 -g_from_file=0 -ncpus=$ncpus -model_name=$model_name -epicenter=$epicenter -fault_name=$fault_name -slab_name=$slab_name -mesh_name=$mesh_name -distances_name=$distances_name -utm_zone=$utm_zone -scaling_law=$scaling_law -dynamic_gflist=$dynamic_gflist -dist_threshold=$dist_threshold -nrealizations=$nrealizations -max_slip=$max_slip -hurst=$hurst -ldip=$ldip -lstrike=$lstrike -lognormal=$lognormal -slip_standard_deviation=$slip_standard_deviation -num_modes=$num_modes -rake=$rake -force_magnitude=$force_magnitude -force_area=$force_area -no_random=$no_random -time_epi=$time_epi -hypocenter=$hypocenter -force_hypocenter=$force_hypocenter -mean_slip=$mean_slip -center_subfault=$center_subfault -use_hypo_fraction=$use_hypo_fraction -source_time_function=$source_time_function -rise_time_depths=$rise_time_depths -shear_wave_fraction=$shear_wave_fraction -gf_list=$gf_list -g_name=$g_name -nfft=$nfft -dt=$dt -dk=$dk -pmin=$pmin -pmax=$pmax -kmax=$kmax -custom_stf=$custom_stf -rupture_list=$rupture_list -target_mw=$target_mw -max_slip_rule=$max_slip_rule -slip_tol=$slip_tol -shear_wave_fraction_deep=$shear_wave_fraction_deep -shear_wave_fraction_shallow=$shear_wave_fraction_shallow -zeta=$zeta -stf_falloff_rate=$stf_falloff_rate -rupture_name=$rupture_name -hot_start=$hot_start -impulse=$impulse -home=$HOMEPATH -project_name=$PROJNAME -run_name=$run_name
fi

# make GFs and Synthetics
python3 /MudPy/examples/fakequakes/planar/mudpy_single_exec_chile.fq.py make_g_files -load_distances=0 -g_from_file=0 -ncpus=$ncpus -model_name=$model_name -epicenter=$epicenter -fault_name=$fault_name -slab_name=$slab_name -mesh_name=$mesh_name -distances_name=$distances_name -utm_zone=$utm_zone -scaling_law=$scaling_law -dynamic_gflist=$dynamic_gflist -dist_threshold=$dist_threshold -nrealizations=$nrealizations -max_slip=$max_slip -hurst=$hurst -ldip=$ldip -lstrike=$lstrike -lognormal=$lognormal -slip_standard_deviation=$slip_standard_deviation -num_modes=$num_modes -rake=$rake -force_magnitude=$force_magnitude -force_area=$force_area -no_random=$no_random -time_epi=$time_epi -hypocenter=$hypocenter -force_hypocenter=$force_hypocenter -mean_slip=$mean_slip -center_subfault=$center_subfault -use_hypo_fraction=$use_hypo_fraction -source_time_function=$source_time_function -rise_time_depths=$rise_time_depths -shear_wave_fraction=$shear_wave_fraction -gf_list=$gf_list -g_name=$g_name -nfft=$nfft -dt=$dt -dk=$dk -pmin=$pmin -pmax=$pmax -kmax=$kmax -custom_stf=$custom_stf -rupture_list=$rupture_list -target_mw=$target_mw -max_slip_rule=$max_slip_rule -slip_tol=$slip_tol -shear_wave_fraction_deep=$shear_wave_fraction_deep -shear_wave_fraction_shallow=$shear_wave_fraction_shallow -zeta=$zeta -stf_falloff_rate=$stf_falloff_rate -rupture_name=$rupture_name -hot_start=$hot_start -impulse=$impulse -home=$HOMEPATH -project_name=$PROJNAME -run_name=$run_name


# Finish the fakequakes simulation; do the last step (make waveforms)
if [[ $runnum -eq 0 ]]; then
    # calc G matrices
    python3 /MudPy/examples/fakequakes/planar/mudpy_single_exec_chile.fq.py make_waveforms -load_distances=0 -g_from_file=0 -ncpus=$ncpus -model_name=$model_name -fault_name=$fault_name -slab_name=$slab_name -mesh_name=$mesh_name -epicenter=$epicenter -distances_name=$distances_name -utm_zone=$utm_zone -scaling_law=$scaling_law -dynamic_gflist=$dynamic_gflist -dist_threshold=$dist_threshold -nrealizations=$nrealizations -max_slip=$max_slip -hurst=$hurst -ldip=$ldip -lstrike=$lstrike -lognormal=$lognormal -slip_standard_deviation=$slip_standard_deviation -num_modes=$num_modes -rake=$rake -force_magnitude=$force_magnitude -force_area=$force_area -no_random=$no_random -time_epi=$time_epi -hypocenter=$hypocenter -force_hypocenter=$force_hypocenter -mean_slip=$mean_slip -center_subfault=$center_subfault -use_hypo_fraction=$use_hypo_fraction -source_time_function=$source_time_function -rise_time_depths=$rise_time_depths -shear_wave_fraction=$shear_wave_fraction -gf_list=$gf_list -g_name=$g_name -nfft=$nfft -dt=$dt -dk=$dk -pmin=$pmin -pmax=$pmax -kmax=$kmax -custom_stf=$custom_stf -rupture_list=$rupture_list -target_mw=$target_mw -max_slip_rule=$max_slip_rule -slip_tol=$slip_tol -shear_wave_fraction_deep=$shear_wave_fraction_deep -shear_wave_fraction_shallow=$shear_wave_fraction_shallow -zeta=$zeta -stf_falloff_rate=$stf_falloff_rate -rupture_name=$rupture_name -hot_start=$hot_start -impulse=$impulse -home=$HOMEPATH -project_name=$PROJNAME -run_name=$run_name
else
    # recycle G matrices
    python3 /MudPy/examples/fakequakes/planar/mudpy_single_exec_chile.fq.py make_waveforms -load_distances=0 -g_from_file=1  -ncpus=$ncpus -model_name=$model_name -fault_name=$fault_name -slab_name=$slab_name -mesh_name=$mesh_name -distances_name=$distances_name -utm_zone=$utm_zone -scaling_law=$scaling_law -dynamic_gflist=$dynamic_gflist -dist_threshold=$dist_threshold -nrealizations=$nrealizations -max_slip=$max_slip -hurst=$hurst -ldip=$ldip -lstrike=$lstrike -lognormal=$lognormal -slip_standard_deviation=$slip_standard_deviation -num_modes=$num_modes -rake=$rake -force_magnitude=$force_magnitude -force_area=$force_area -no_random=$no_random -time_epi=$time_epi -hypocenter=$hypocenter -force_hypocenter=$force_hypocenter -mean_slip=$mean_slip -center_subfault=$center_subfault -use_hypo_fraction=$use_hypo_fraction -source_time_function=$source_time_function -rise_time_depths=$rise_time_depths -shear_wave_fraction=$shear_wave_fraction -gf_list=$gf_list -g_name=$g_name -nfft=$nfft -dt=$dt -dk=$dk -pmin=$pmin -pmax=$pmax -kmax=$kmax -custom_stf=$custom_stf -rupture_list=$rupture_list -target_mw=$target_mw -max_slip_rule=$max_slip_rule -slip_tol=$slip_tol -shear_wave_fraction_deep=$shear_wave_fraction_deep -shear_wave_fraction_shallow=$shear_wave_fraction_shallow -zeta=$zeta -stf_falloff_rate=$stf_falloff_rate -rupture_name=$rupture_name -hot_start=$hot_start -impulse=$impulse -home=$HOMEPATH -project_name=$PROJNAME -run_name=$run_name
fi

# deactivate the python environment built in to this Singularity image
cd /
. quake3.6/bin/deactivate
cd ~



# --- The next lines wrap up the matrices to be easily recycled 

# if is the initial run
if [[ $runnum -eq 0 ]]; then
    # Get the matrices from the output and save into a tarball
    mkdir matricesoutput        # new directory for output

    # Copy the matrices into a directory to be output
    cd $HOMEPATH/$PROJNAME/data/distances         # navigate
    cp *.npy ~/matricesoutput    # copy the distance matrices to the new dir
    cd ../../GFs/matrices               # navigate 
    cp *.mseed ~/matricesoutput  # copy the G matrices to the new dir
    cd ~                         # go back to the top-level directory of the execute node

    # Compress the matrix files into a tarball. This tarball will be automatically transferred to the home dir of the user's login node
    tar -czf matricesoutput.tar.gz matricesoutput 
fi


